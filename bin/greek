#!/usr/bin/env perl
use v5.32.0;
use warnings;
use utf8;

use experimental 'signatures';

binmode *STDIN,  ':encoding(utf-8)';
binmode *STDOUT, ':encoding(utf-8)';

my sub greek ($c) {
  state @DIGIT = qw( ê˜  ê˜¢ ê˜£ ê˜¤ ê˜¥ ê˜¦ ê˜§ ê˜¨ ê˜© );

  state @UPPER = qw(
    á‚  á‚¡ á‚¢ á‚£ á‚¤ á‚¥ á‚¦ á‚§ á‚¨ á‚© á‚ª á‚« á‚¬ á‚­ á‚® á‚¯ á‚° á‚± á‚²
    á‚³ á‚´ á‚µ á‚¶ á‚· á‚¸ á‚¹ á‚º á‚» á‚¼ á‚½ á‚¾ á‚¿ áƒ€ áƒ áƒ‚ áƒƒ áƒ„ áƒ…
  );

  state @LOWER = qw(
    ğ¤¢ ğ¤£ ğ¤¤ ğ¤¥ ğ¤¦ ğ¤§ ğ¤¨ ğ¤© ğ¤ª ğ¤« ğ¤¬ ğ¤­ ğ¤® ğ¤¯ ğ¤° ğ¤± ğ¤²
    ğ¤³ ğ¤´ ğ¤µ ğ¤¶ ğ¤· ğ¤¸ ğ¤¹ ğ¤º ğ¤» ğ¤¼ ğ¤½ ğ¤¾ ğ¤¿ ğ¥€ ğ¥ ğ¥‚ ğ¥ƒ
  );

  state @OTHER = qw(
    ß‹ ßŒ ß ß ß ß ß‘ ß’ ß“ ß” ß• ß– ß— ß˜ ß™ ßš ß› ßœ
    ß ß ßŸ ß  ß¡ ß¢ ß£ ß¤ ß¥ ß¦
  );

  local $_ = $c;

  my $o = ord;
  $o += $$;

  if (/\d/)     { return $DIGIT[ $o % @DIGIT ]; }
  if (/\p{Lu}/) { return $UPPER[ $o % @UPPER ]; }
  if (/\p{Ll}/) { return $LOWER[ $o % @LOWER ]; }
  # I should probably handle ideographs at this point. -- rjbs, 2023-06-21
  if (/\p{Lo}/) { return $OTHER[ $o % @OTHER ]; }

  return $_;
}

while (<>) {
  my @hunks = split /(\e\[ [\d;]* m)/x, $_;
  for (@hunks) {
    next if /\A\e/;
    s/(\w)/greek($1)/ge;
  }

  $_ = join q{}, @hunks;

  print;
}

