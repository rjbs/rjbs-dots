#!/usr/bin/perl
use strict;
use warnings;

my %opt = ('--debug' => 0, '--force' => 0, '--really' => 0);
$opt{$_}++ for @ARGV;

die "duplicating options is weird\n" if grep {; $_ > 1 } values %opt;

my $debug  = delete $opt{'--debug'};
my $force  = delete $opt{'--force'};
my $really = delete $opt{'--really'};

die "unknown options provided; only --really and --debug work\n" if keys %opt;

my $home = $ENV{HOME};
die "no \$HOME set, so... what?\n" unless $home;

my $cwd  = $ENV{PWD};

my @files = `git ls-files`;
die "couldn't run `git ls-files` for some reason: $!\n" if $?;

chomp @files;

my %made;

FILE: for my $file (@files) {
  # Never makes sense to copy this.
  next if $file eq '.gitignore';
  next if $file eq '.gitmodules';

  my @parts  = split m{/}, $file;
  my $target = $home;

  if (@parts > 1) {
    my $path = join q{/}, splice @parts, 0, @parts-1;
    $target = "$home/$path";

    unless ($made{$path}++) {
      next if -d $target;
      warn "EXEC: mkdir -p $target\n";
      if ($really) {
        system('mkdir', '-p', $target) && die "couldn't make $target: $!";
      }
    }
  }

  if (-e "$home/$file") {
    if (-l "$home/$file" && readlink("$home/$file") eq "$cwd/$file") {
      if ($debug) {
        warn "SKIP: $home/$file already links to $cwd/$file\n";
      }
      next FILE
    }

    unless ($force) {
      warn "SKIP: $home/$file which exists but isn't a link to $cwd/$file\n";
      next FILE;
    }

    warn "EXEC: rm $home/$file\n";
    if ($really) {
      system('rm', "$home/$file") && die "couldn't rm $home/$file: $!";
    }
  }

  warn "EXEC: ln -s $cwd/$file $target\n";
  if ($really) {
    system 'ln', '-s', "$cwd/$file", $target;
    die "error symlinking" if $?;
  }
}
